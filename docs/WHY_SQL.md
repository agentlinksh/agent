# Why SQL as a Superpower

A deeper look at why Agent Link moves business logic into the database — and honest answers to the pushback.

---

## The Benefits

### Performance

Logic executes where the data lives. No network roundtrip between an app server and the database. A function that joins three tables, filters, and aggregates runs entirely in-process. For something like "get all orders for this tenant with their line items and totals," the difference is meaningful.

### Transactional Integrity

A Postgres function runs in a single transaction by default. Multi-step operations — create order, update inventory, log event — are atomic without you coordinating anything. In an app server, you'd need to manage transaction boundaries explicitly.

### Security Can't Be Bypassed

With RLS + SECURITY INVOKER, access control is enforced at the database level regardless of who's calling. A new frontend, a mobile app, a third-party integration — they all go through the same security layer. You can't accidentally forget an auth check in a new endpoint because there's no endpoint to forget it in.

### One Backend, Every Frontend

The RPC layer auto-generated by PostgREST serves web, mobile, desktop, and other agents equally. No BFF layer, no separate API servers per client, no duplicated logic.

### Fewer Moving Parts

No app server to deploy, scale, patch, or monitor. The infrastructure is simpler. For internal tools and business software, this is a real operational win.

### Schema and Logic Travel Together

Migrations contain both the data model and the business logic. One version-controlled history. No drift between your schema and the code that operates on it.

---

## The Pushback

### "Separation of Concerns"

This is the big one. Traditional architecture says: database stores data, application layer handles logic. Mixing them is considered an anti-pattern by many.

The counterargument is that this principle was designed for human teams maintaining code across layers. When an agent is building, it reasons about the full stack regardless of where logic lives. The "separation" was organizational, not technical.

### "SQL Isn't Expressive Enough for Complex Logic"

PL/pgSQL is more limited than TypeScript or Python for things like string manipulation, complex conditionals, or deeply nested logic. This is real.

But the Agent Link architecture addresses it: complex external integrations go in Edge Functions, not in SQL. The SQL layer handles data logic — queries, mutations, validation, access control — which is exactly what SQL was designed for.

### "Testability"

SQL functions are harder to test than application code with mature frameworks like Jest or pytest. pgTAP exists but the ecosystem is thinner.

This is a real gap and exactly why the Testing rune matters — it needs to make testing SQL-based logic as painless as possible.

### "Scalability"

App servers scale horizontally easily. Databases are harder to scale. Putting more logic on the database adds load where it's hardest to expand.

For internal tools and business software, this is rarely an issue. For a high-traffic consumer app, it could be. But that's outside Agent Link's scope by design — "Built for Business" is doing real work here as a scoping principle.

### "Vendor Lock-in"

Logic in Postgres functions is tied to Postgres. True. But if you're using Supabase, you're already on Postgres. And the lock-in argument assumes you might migrate databases — in practice, teams rarely do, and when they do, the application logic needs rewriting regardless.

### "Developer Skills"

Most developers are more comfortable in TypeScript than PL/pgSQL. This was a valid concern when developers were writing all the code by hand.

But Agent Link isn't optimized for developers writing code — it's optimized for agents writing code. And agents write SQL as fluently as anything else.

---

## The Pattern

Almost every counterargument is rooted in human limitations that agents don't share.

- Debugging is hard in SQL → agents read logs
- PL/pgSQL is less expressive → agents don't care about ergonomics
- Developers don't know SQL well enough → agents do
- Testing is harder → solvable with the right skill

The one counterargument that stands on pure technical merit is scalability. Agent Link scopes around it with "Built for Business" — the kind of software where database load from business logic is rarely the bottleneck.

The reason we put distance between ourselves and the database was never because the database was the wrong place for the logic. It was because *we* struggled to work there efficiently. Agents don't.
